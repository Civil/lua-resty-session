# lua-resty-session

**lua-resty-session** is a session library for OpenResty implementing [Secure Cookie Protocol](http://www.cse.msu.edu/~alexliu/publications/Cookie/cookie.pdf).

## Hello World with lua-resty-session

```nginx
http {
    server {
        listen       8080;
        server_name  localhost;
        default_type text/html;
        location / {
            content_by_lua '
                ngx.say("<html><body><a href=/start>Start the test</a>!</body></html>")
            ';
        }
        location /start {
            content_by_lua '
                local session = require "resty.session".start()
                session.data.name = "OpenResty Fan"
                session:save()
                ngx.say("<html><body>Session started. ",
                        "<a href=/test>Check if it is working</a>!</body></html>")
            ';
        }
        location /test {
            content_by_lua '
                local session = require "resty.session".start()
                ngx.say("<html><body>Session was started by <strong>",
                        session.data.name or "Anonymous",
                        "</strong>! <a href=/destroy>Destroy the session</a>.</body></html>")
            ';
        }
        location /destroy {
            content_by_lua '
                local session = require "resty.session".start()
                session:destroy()
                ngx.say("<html><body>Session was destroyed. ",
                        "<a href=/check>Is it really so</a>?</body></html>")
            ';
        }
        location /check {
            content_by_lua '
                local session = require "resty.session".start()
                ngx.say("<html><body>Session was really destroyed, you are known as <strong>",
                        session.data.name or "Anonymous",
                        "</strong>! <a href=/>Start again</a>.</body></html>")
            ';
        }
    }
}
```

## About The Defaults

```lua-resty-session``` does by default set session only cookies (non-persistent, ```HttpOnly```) so that
the cookies are not readable from Javascript (not subjectible to XSS in that matter). It will also set
```Secure``` flag by default when the request was made via SSL/TLS connection. Cookies send via SSL/TLS
don't work when sent via HTTP and vice-versa. By default the HMAC key is generated from session id (random
bytes generated with OpenSSL), expiration time, unencrypted data, and Nginx variables ```ssl_session_id```
(if requested with TLS/SSL), ```http_user_agent``` and ```scheme```. You may also configure it to use
```remote_addr``` as well by setting ```set $session_check_addr off;``` (but this may be problematic
with clients behind proxies or NATs that change the remote address between requests).

The data part is encrypted with AES-algorithm (by default it uses OpenSSL ```EVP_aes_256_cbc``` and
```EVP_sha512``` functions that are provided with ```lua-resty-string```. They come preinstalled with
the default OpenResty bundle. The ```lua-resty-session``` library is not tested with all the
```resty.aes``` functions (but the defaults are tested to be working). Please let me know or contact
```lua-resty-string``` project if you hit any problems with different algorithms.

Session identifier length is by default 16 bytes (randomly generated data with OpenSSL
```RAND_pseudo_bytes``` function. The server secret is also generated by default with this same
function, and it's length is determined by calculating the used ```$session_cipher_size``` divided
by 8 (so by default it uses 32 bytes). This will work until Nginx is restarted, but you might want
to consider setting your own secret using ```set $session_secret 623q4hR325t36VsCD3g567922IC0073T;``,
for example (this will work in farms installations as well, but you are then responsible for
rotating the secret). On farm installations you should also configure other session configuration
variables the same.

Cookie parts are encoded with cookie safe Base64 encoding. Before encrypting and encoding the data
part, the data is serialized with JSON encoding (so you can use basic Lua types in data, and expect
to receive them back as the same Lua types). JSON encoding is done by the bundled OpenResty cJSON
library (Lua cJSON). Cookie's path scope is by default ```/``` (meaning that it will be send to all paths
in the server, and the Domain scope is the current host determined by ```host``` Nginx variable (meaning
that the browser will only send cookie back to the same host from which it got it on a first place).

There is no state held in server (except the configuration directives), and all the data is stored
in the cookie as specified in Secure Cookie Protocol paper. In the future, the server side backend
could be added to this module as well (all contributions are welcomed).

## Lua API

#### table session.start(opts or nil)

With this function you can start a new session. It will create a new session Lua ```table``` on each call.
Right now you should only start session once as calling this function repeatedly will overwrite the previously
started session cookie. This function will return a new session ```table``` as a result. If the session cookie
is supplied with user's HTTP(S) client then this function validates the supplied session cookie. If validation
is successful, the user supplied session data will be used (if not, a new session is generated with empty data).
You may supply optional session configuration variables with ```opts``` argument, but be aware that many of these
will only have effect if the session is a fresh session (i.e. not loaded from user supplied cookie). This function
does also manage session cookie renewing configured with ```$session_cookie_renew```. E.g. it will send a new cookie
with a new expiration time if the following is met ```session.expires - now < session.cookie.renew```.

```lua
local session = require "resty.template".start()
-- Set some options (overwriting the defaults or nginx configuration variables)
local session = require "resty.template".start{ identifier = { length = 32 }}
```

#### boolean session:regenerate(flush or nil)

This function regenerates a session. It will generate a new session identifier and optionally flush the
session data if ```flush``` argument evaluates ```true```. It will automatically ```session:save``` which
means that a new expires flag is set on the cookie, and the data is encrypted with the new parameters. With
client side sessions (server side sessions are not yet supported) this overwrites the current cookie with
a new one (but it doesn't invalidate the old one as there is no state held on server side - invalidation
actually happens when the cookie's expiration time is not valid anymore). This function returns a boolean
value if everything went as planned (you may assume that it is always the case).

```lua
local session = require "resty.template".start()
session:regenerate()
-- Flush the current data
session:regenerate(true)
```

#### boolean session:save()

This function saves the session and sends a new cookie to client (with a new expiration time and encrypted data).
You need to call this function whenever you want to save the changes made to ```session.data``` table. It is
advised that you call this function only once per request (no need to encrypt and set cookie many times).
This function returns a boolean value if everything went as planned (you may assume that it is always the case).

```lua
local session = require "resty.template".start()
session.data.uid = 1
session:save()
```

#### boolean session:destroy()

This function will immediately set session data to empty table ```{}```. It will also send a new cookie to
client with empty data and Expires flag ```Expires=Thu, 01 Jan 1970 00:00:01 GMT``` (meaning that the client
should remove the cookie, and not send it back again). This function returns a boolean value if everything went
as planned (you may assume that it is always the case).

```lua
local session = require "resty.template".start()
session:destroy()
```

### Session Fields

#### string session.id
#### number session.identifier.length
#### string session.secret
#### number session.cookie.renew
#### number session.cookie.lifetime
#### string session.cookie.path
#### string session.cookie.domain
#### boolean session.cookie.secure
#### boolean session.cookie.httponly
#### number session.cipher.size
#### string session.cipher.mode
#### function session.cipher.hash
#### number session.cipher.rounds

## Nginx Configuration Variables

Here is a list of Nginx configuration variables that you can use to control ```lua-resty-session```:

```nginx
set $session_name              session;
set $session_secret            623q4hR325t36VsCD3g567922IC0073T;
set $session_cookie_renew      600;
set $session_cookie_lifetime   3600;
set $session_cookie_path       /;
set $session_cookie_domain     openresty.org;
set $session_cookie_secure     on;
set $session_cookie_httponly   on;
set $session_cipher_mode       cbc;
set $session_cipher_size       256;
set $session_cipher_hash       sha512;
set $session_cipher_rounds     1;
set $session_check_ua          on;
set $session_check_scheme      on;
set $session_check_addr        off;
set $session_identifier_length 16;
```

## License

`lua-resty-session` uses two clause BSD license.

```
Copyright (c) 2014, Aapo Talvensaari
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES`